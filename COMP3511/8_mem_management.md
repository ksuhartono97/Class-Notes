# Memory Management Strategies

## Address Binding

Binding of instructions and data to memory can happy at three different stages:

- Compile time: very inefficient, every time starting location changes, code needs to be recompiled
- Load time : compiler doesn't need to know memory address, only need to reload the user code if the starting location is changed. Abstract start and end memory address, so it can be relocatable.
- Execution time : every time the program is run, there is a new memory address generated. Implying that every time you run it, the address is always different.

> In compile and load time, if you launch program without recompile or reloading, then the program would launch in the same memory address. However in execution time, the program will always launch in a different address, it depends on the current memory situation.

Problem with the compile and load time, if the memory address you give the program is currently being used by another process, then the current program cannot run. Which means that this is a poor utilization of memory. Only used this system in the old days, when there are only a small number of processes to run, so less likely to share the same space.

### MMU (Memory Management Unit)

Maps virtual addresses to physical addresses. User programs only deals with logical addresses, **never sees** the real physical address.

> Logical address is generated by the CPU, also referred to as the virtual address. Physical address is address as seen by the memory unit.

#### Swapping

Transfer time of swapping depends on the size of the process you want to transfer and the bandwidth / transfer speed.

#### Contiguous Allocation

OS occupies the lower address part of the memory space exclusively.

In contiguous allocation, the entire process image occupies contiguous memory locations inside the main memory.

Physical address is basically logical address + relocation register address (the value pointed by it). Note that the logical address must be valid. Basically simply add onto each other because we just want the processes to be contiguous.

### Dynamic Storage Allocation Problem

After allocating processes for awhile, there are **holes** scattered across the memory. Due to contiguous allocation, there are holes because the memory was allocated connected to each other. When the process that used the memory is freed, there is a hole that was left behind. Basically the free memory becomes scattered around.

This problem can be solved but with terrible overhead.

If a process comes and requests a size from a list of free holes, what can we do? Three options:

- First-fit: first hole that is big enough
- Best-fit : out of all the holes that satisfy the requirements, pick the smallest one
- Worst-fit : similar to best-fit but pick the largest one. Basically hoping that someone else can use the remaining size of the hole that is left behind.

### Segmentation

Memory management scheme that supports user view of memory, a program consists of segments.

### Page Tables

Framesize is page size. Will allocate memory into multiple pages (frames), that are not contiguous.

Hierarchical Paging is applying a two-level page table.

> Offset is 12 bits (4Kb)

Total page number is 20 bits, divide into two for P1 and P2\. Where each level points to the next level.

Problem, in n levels page table, you need to enter the memory n + 1 times. Once for every level, and then once more to actually fetch the data. Causing a large wait time. (See address translation scheme)

On a 64 bit system, the size of the outer page is too large, 2^42 bits, such that even a four level paging scheme won't be able to handle the size. Would need five or six level to handle, but memory access speed would be really slow.
